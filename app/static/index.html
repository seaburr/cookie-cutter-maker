<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cookie Cutter Maker</title>
  <style>
    body, button, input, textarea, select { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body {
      margin: 0;
      background: radial-gradient(circle at 15% 15%, #111926 0%, #0b0f14 32%, #0a0d13 100%);
      color: #e6edf3;
    }
    header { padding: 24px 28px; border-bottom: 1px solid #1f2a37; display:flex; align-items:center; justify-content:space-between;}
    main { display:flex; flex-direction:column; gap: 28px; padding: 16px; max-width: 1280px; margin: 0 auto; }
    .card { background: linear-gradient(145deg, #0f1824, #0c121a); border: 1px solid #1f2a37; border-radius: 16px; padding: 18px; box-shadow: 0 16px 40px rgba(0,0,0,0.35); }
    h2 { margin: 0 0 12px 0; font-size: 18px; font-weight:800; letter-spacing: 0.2px; }
    label { display:block; font-size: 12px; color:#9fb0c2; margin-top: 12px; margin-bottom:6px; letter-spacing: 0.1px; }
    input[type="text"], textarea { width:100%; background:#0b0f14; border:1px solid #243244; color:#e6edf3; border-radius:12px; padding:12px; }
    .short-input { width:80%; max-width:420px; }
    input[type="file"] { width:100%; color:#e6edf3; background:#0b0f14; border:1px solid #243244; border-radius:12px; padding:12px; cursor:pointer; }
    input[type="file"]::file-selector-button { background:#223043; color:#e6edf3; border:0; border-radius:10px; padding:10px 14px; margin-right:12px; cursor:pointer; font-weight:700; }
    input[type="file"]::file-selector-button:hover { background:#1f6feb; }
    .row { display:flex; gap:10px; }
    .row > div { flex:1; }
    input[type="range"] { width:100%; }
    .tip { position:relative; display:inline-flex; align-items:center; justify-content:center; margin-left:6px; width:16px; height:16px; border:1px solid #2b3b4f; border-radius:50%; font-size:11px; line-height:14px; color:#9fb0c2; cursor:help; }
    .tip:hover { color:#e6edf3; border-color:#3b4f66; background:#162235; }
    .tip::after {
      content: attr(data-tip);
      position:absolute;
      left:50%;
      top:22px;
      transform: translateX(-50%);
      min-width: 180px;
      max-width: 260px;
      background:#111927;
      color:#e6edf3;
      border:1px solid #2b3b4f;
      border-radius:8px;
      padding:8px 10px;
      font-size:11px;
      line-height:1.3;
      box-shadow:0 8px 20px rgba(0,0,0,0.35);
      opacity:0;
      pointer-events:none;
      transition: opacity 120ms ease-out;
      z-index:10;
      white-space: normal;
    }
    .tip::before {
      content:"";
      position:absolute;
      left:50%;
      top:14px;
      transform: translateX(-50%);
      width:8px; height:8px;
      background:#111927;
      border-left:1px solid #2b3b4f;
      border-top:1px solid #2b3b4f;
      transform: translateX(-50%) rotate(45deg);
      opacity:0;
      transition: opacity 120ms ease-out;
      z-index:10;
    }
    .tip:hover::after, .tip:hover::before { opacity:1; }
    button { width:100%; margin-top:12px; background:#223043; border:0; color:white; padding:12px 14px; border-radius:12px; font-weight:700; cursor:pointer; transition:background 120ms ease-out, transform 120ms ease-out; letter-spacing:0.1px; }
    button.secondary { background:#223043; }
    button:hover { background:#1f6feb; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .preview { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .pane { background:#0b0f14; border:1px solid #1f2a37; border-radius: 14px; overflow:hidden; min-height: 320px; }
    .pane header { padding:12px 14px; border-bottom:1px solid #1f2a37; font-size:12px; color:#9fb0c2; text-align:left; letter-spacing:0.2px; }
    .pane .content { padding:16px; min-height:340px; height:100%; box-sizing:border-box; }
    .pane.media .content { display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:12px; width:100%; }
    .pane.text .content { display:block; text-align:left; padding-right:12px; padding-left:12px; }
    .pane img, .pane iframe { width:100%; max-width:420px; aspect-ratio:1/1; height:auto; border:0; background:white; border-radius:12px; object-fit: contain; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
    #pngPreview, #svgPreview { width:100%; max-width:520px; aspect-ratio:1/1; background:white; border-radius:12px; box-shadow:0 12px 30px rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; overflow:hidden; color:#0d1117; padding:6px; box-sizing:border-box; }
    #pngPreview img, #svgPreview img { width:100%; height:100%; object-fit:contain; border:0; }
    #svgPreview iframe { width:100%; height:100%; border:0; }
    #stlCanvas { width:100%; max-width:none; aspect-ratio: 16 / 10; min-height: 420px; height: clamp(420px, 70vw, 640px); border-radius:12px; background:#0d1117; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
    #stlStatus { font-size:12px; color:#9fb0c2; text-align:center; margin-top:auto; min-height:16px; display:flex; align-items:center; justify-content:center; width:100%; }
    .links a { color:#7ee787; text-decoration:none; display:block; margin-top:6px; }
    .small { font-size: 12px; color:#9fb0c2; line-height:1.4; }
    .tabs { display:flex; gap:8px; margin-bottom: 10px; }
    .tab { flex:1; padding:10px; border-radius:12px; border:1px solid #1f2a37; background:#0b0f14; color:#c9d1d9; cursor:pointer; font-weight:600; }
    .tab.active { background:#162235; border-color:#2b3b4f; color:#e6edf3;}
    .step-grid { display:grid; grid-template-columns: minmax(420px, 1.15fr) 460px 240px; gap:20px; align-items:start; }
    .step3-grid { grid-template-columns: 340px 1fr; align-items:stretch; }
    .stl-controls { display:flex; flex-direction:column; gap:10px; }
    .stl-controls .row { flex-direction:column; gap:10px; }
    .stl-controls .row > div { flex: none; }
    .stl-controls input[type="range"] { height:6px; }
    .stl-controls label { margin-top: 6px; }
  </style>
</head>
<body>
<header>
  <div>
    <div style="font-weight:900; font-size:20px;">Cookie Cutter Maker</div>
    <div class="small">Upload and prompt → Trace → Generate STL</div>
  </div>
</header>

<main>
  <div class="card step-grid">
    <div>
      <h2>Step 1: Get an outline (PNG)</h2>
      <div class="tabs">
        <button class="tab active" id="tabPng" type="button">PNG Upload</button>
        <button class="tab" id="tabPrompt" type="button">Prompt (optional)</button>
      </div>

      <div id="panePng">
        <label>Outline image (black on white)</label>
        <input id="file" type="file" accept=".png,.jpg,.jpeg" />
      </div>

      <div id="panePrompt" style="display:none;">
        <label>Prompt</label>
        <textarea id="prompt" rows="4" placeholder="e.g., a pajama shirt icon silhouette, single closed contour, simple outline"></textarea>
        <div class="small" style="margin-top:6px;">
          Requires <code>OPENAI_API_KEY</code> set in the container. Otherwise this endpoint will return an error.
        </div>
      </div>

      <label>Name</label>
      <input id="name" class="short-input" type="text" value="cookie_cutter" />

      <button id="btnStep1" class="secondary" type="button">Load outline (upload or prompt)</button>
    </div>
    <div class="pane media">
      <header>PNG</header>
      <div class="content">
        <div id="pngPreview" class="small">Step 1 will show your uploaded/generated PNG.</div>
      </div>
    </div>
    <div class="pane text">
      <header>Tips</header>
      <div class="content small">
        <ul>
          <li>Use a single closed silhouette outline (no interior lines).</li>
          <li>High-contrast black on white PNGs trace best.</li>
          <li>Keep shapes simple; avoid thin lines.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="card step-grid">
    <div>
      <h2>Step 2: Trace tuning (SVG)</h2>
      <div class="row">
        <div>
          <label>Threshold: <span id="thrVal">200</span> <span class="tip" data-tip="Black/white cutoff for tracing; lower = more pixels counted as ink.">?</span></label>
          <input id="thr" type="range" min="50" max="250" value="200" step="1"/>
        </div>
        <div>
          <label>Simplify: <span id="simpVal">0.002</span> <span class="tip" data-tip="Douglas-Peucker tolerance; higher = fewer nodes and smoother outline.">?</span></label>
          <input id="simp" type="range" min="0.0005" max="0.01" value="0.002" step="0.0005"/>
        </div>
      </div>
      <button id="btnTrace" class="secondary" type="button">Trace</button>
    </div>
    <div class="pane media">
      <header>Traced SVG</header>
      <div class="content">
        <div id="svgPreview" class="small">Run step 1, then step 2 to preview.</div>
      </div>
    </div>
    <div class="pane text">
      <header>Tips</header>
      <div class="content small">
        <ul>
          <li>If tracing is jagged, increase <b>Simplify</b>.</li>
          <li>If outline disappears, adjust <b>Threshold</b>.</li>
          <li>Re-run this step as much as you need; no new prompt tokens.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="card step-grid step3-grid">
    <div class="stl-controls">
      <h2>Step 3: STL settings</h2>

      <div class="row">
        <div>
          <label>Width (mm): <span id="widthVal">95</span> <span class="tip" data-tip="Overall cutter width across its widest point.">?</span></label>
          <input id="width" type="range" min="40" max="160" value="95" step="1"/>
        </div>
        <div>
          <label>Wall (mm): <span id="wallVal">1.0</span> <span class="tip" data-tip="Thickness of the cutting wall. Increase to strengthen thin shapes.">?</span></label>
          <input id="wall" type="range" min="0.8" max="2.0" value="1.0" step="0.1"/>
        </div>
      </div>

      <div class="row">
        <div>
          <label>Total height (mm): <span id="heightVal">28</span> <span class="tip" data-tip="Overall wall height of the cutter.">?</span></label>
          <input id="height" type="range" min="16" max="40" value="28" step="1"/>
        </div>
        <div>
          <label>Flange height (mm): <span id="flangeHVal">7.226</span> <span class="tip" data-tip="How tall the grip flange is above the cutting edge.">?</span></label>
          <input id="flangeH" type="range" min="3" max="14" value="7.226" step="0.1"/>
        </div>
      </div>

      <label>Flange outward (mm): <span id="flangeOutVal">6</span> <span class="tip" data-tip="How far the grip flange sticks out horizontally.">?</span></label>
      <input id="flangeOut" type="range" min="0" max="12" value="6" step="0.5"/>

      <div class="row">
        <div>
          <label>Cleanup (mm): <span id="cleanupVal">0.5</span> <span class="tip" data-tip="Morphological smoothing to remove tiny zig-zags or noise before offsetting.">?</span></label>
          <input id="cleanup" type="range" min="0" max="2" value="0.5" step="0.1"/>
        </div>
        <div>
          <label>Tip smoothing (mm): <span id="tipSmoothVal">0.6</span> <span class="tip" data-tip="Rounds sharp corners so inner offsets don’t collapse to paper-thin walls.">?</span></label>
          <input id="tipSmooth" type="range" min="0" max="2" value="0.6" step="0.05"/>
        </div>
        <div>
          <label>Keep holes <span class="tip" data-tip="Preserve interior holes instead of filling them before offsetting.">?</span></label>
          <input id="keepHoles" type="checkbox" />
        </div>
      </div>
      <label>Min island area (mm²): <span id="areaVal">25</span> <span class="tip" data-tip="Discard tiny disconnected islands below this area to avoid fragile crumbs.">?</span></label>
      <input id="area" type="range" min="1" max="200" value="25" step="1"/>

      <button id="btnRun" type="button">Generate STL</button>
      <div id="status" class="small" style="margin-top:10px;"></div>
      <div class="links" id="links"></div>
    </div>
    <div class="pane media">
      <header>STL Preview</header>
      <div class="content">
        <canvas id="stlCanvas"></canvas>
        <div id="stlStatus" class="small">Generate STL to preview.</div>
      </div>
    </div>
  </div>

</main>

<script>
  // Lightweight STL viewer via Three.js + STLLoader.
  // Tries local copies in /static first; falls back to CDN if not present.
  let renderer, scene, camera, controls, stlMesh;
  async function ensureThree() {
    if (window.THREE && window.STLLoader && window.OrbitControls) return;
    const localLibs = [
      "/static/three.min.js",
      "/static/STLLoader.js",
      "/static/OrbitControls.js",
    ];
    const cdnLibs = [
      "https://unpkg.com/three@0.158.0/build/three.min.js",
      "https://unpkg.com/three@0.158.0/examples/js/loaders/STLLoader.js",
      "https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js",
    ];
    const tryLoad = (src) =>
      new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.crossOrigin = "anonymous";
        s.onload = resolve;
        s.onerror = () => reject(new Error("Failed to load " + src));
        document.head.appendChild(s);
      });
    try {
      for (const src of localLibs) await tryLoad(src);
    } catch (e) {
      // fallback to CDN
      for (const src of cdnLibs) await tryLoad(src);
    }
  }

  function initStlViewer() {
    const canvas = document.getElementById('stlCanvas');
    if (!canvas) return;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight || Math.round(canvas.clientWidth * 0.625);
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(w, h, false);
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
    camera.position.set(0, 0, 120);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light = new THREE.HemisphereLight(0xffffff, 0x222233, 1.1);
    scene.add(light);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(60, 80, 100);
    scene.add(dir);

    const grid = new THREE.GridHelper(160, 8, 0x334155, 0x1e293b);
    grid.position.y = -40;
    scene.add(grid);

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    window.addEventListener('resize', () => {
      if (!renderer || !camera) return;
      const sizeW = canvas.clientWidth;
      const sizeH = canvas.clientHeight || Math.round(sizeW * 0.625);
      renderer.setSize(sizeW, sizeH, false);
      camera.aspect = sizeW / sizeH;
      camera.updateProjectionMatrix();
    });
  }

  window.loadStl = async (url) => {
    try {
      const status = document.getElementById('stlStatus');
      if (status) status.textContent = 'Loading STL viewer...';
      await ensureThree();
      if (!renderer) initStlViewer();
      if (status) status.textContent = 'Loading STL mesh...';
      console.log('loadStl fetching', url);
      const loader = new THREE.STLLoader();
      loader.load(url, (geom) => {
        console.log('loadStl success', url);
        if (stlMesh) {
          scene.remove(stlMesh);
          stlMesh.geometry.dispose();
        }
        geom.computeBoundingBox();
        const mat = new THREE.MeshStandardMaterial({ color: 0x8ab4f8, metalness: 0.1, roughness: 0.35 });
        stlMesh = new THREE.Mesh(geom, mat);
        scene.add(stlMesh);

        const bbox = geom.boundingBox;
        const size = bbox.getSize(new THREE.Vector3());
        const center = bbox.getCenter(new THREE.Vector3());
        stlMesh.position.sub(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        const camDist = maxDim * 1.6;
        camera.position.set(camDist, camDist, camDist);
        camera.lookAt(0,0,0);
        controls.target.set(0,0,0);
        controls.update();

        const status = document.getElementById('stlStatus');
        if (status) status.textContent = 'Drag to orbit • Scroll to zoom';
      }, undefined, (err) => {
        const status = document.getElementById('stlStatus');
        if (status) status.textContent = 'Failed to load STL';
        console.error(err);
      });
    } catch (e) {
      const status = document.getElementById('stlStatus');
      if (status) status.textContent = 'Viewer failed to load';
      console.error('loadStl error', e);
    }
  };

  const $ = (id) => document.getElementById(id);

  function bindRange(id, outId, fmt=(v)=>v) {
    const el = $(id);
    const out = $(outId);
    const upd = () => out.textContent = fmt(el.value);
    el.addEventListener('input', upd);
    upd();
  }

  bindRange('width','widthVal');
  bindRange('wall','wallVal', v => Number(v).toFixed(1));
  bindRange('height','heightVal');
  bindRange('flangeH','flangeHVal', v => Number(v).toFixed(3));
    bindRange('flangeOut','flangeOutVal');
    bindRange('thr','thrVal');
    bindRange('simp','simpVal', v => Number(v).toFixed(4));
    bindRange('cleanup','cleanupVal', v => Number(v).toFixed(1));
    bindRange('tipSmooth','tipSmoothVal', v => Number(v).toFixed(2));
    bindRange('area','areaVal');

  // Tabs
  const tabPng = $('tabPng');
  const tabPrompt = $('tabPrompt');
  const panePng = $('panePng');
  const panePrompt = $('panePrompt');
  let mode = 'png';
  let lastJobId = null;
  let lastPngUrl = null;

  tabPng.onclick = () => {
    mode = 'png';
    tabPng.classList.add('active'); tabPrompt.classList.remove('active');
    panePng.style.display = ''; panePrompt.style.display = 'none';
  };
  tabPrompt.onclick = () => {
    mode = 'prompt';
    tabPrompt.classList.add('active'); tabPng.classList.remove('active');
    panePrompt.style.display = ''; panePng.style.display = 'none';
  };

  function setStatus(msg) { $('status').textContent = msg; }
  function updatePreviews(obj) {
    console.log('updatePreviews payload:', obj);
    if (obj?.png) {
      lastPngUrl = obj.png;
      $('pngPreview').innerHTML = `<img src="${obj.png}" alt="PNG preview">`;
    }
    if (obj?.svg) {
      $('svgPreview').innerHTML = `<iframe src="${obj.svg}" aria-label="SVG preview"></iframe>`;
    }
    if (obj?.stl && typeof window.loadStl === 'function') {
      window.loadStl(obj.stl);
    }
  }
  function setLinks(obj) {
    const links = $('links');
    links.innerHTML = '';
    if (!obj) return;
    for (const [k,v] of Object.entries(obj)) {
      if (k === 'job_id') continue;
      if (typeof v === 'string' && v.startsWith('/files/')) {
        const a = document.createElement('a');
        a.href = v;
        if (k.toLowerCase() === 'zip') {
          a.textContent = 'Download All (zip)';
        } else {
          a.textContent = `Download ${k.toUpperCase()}`;
        }
        a.target = '_blank';
        links.appendChild(a);
      }
    }
    if (obj.job_id) {
      const div = document.createElement('div');
      div.className = 'small';
      div.style.marginTop = '10px';
      div.style.textAlign = 'center';
      div.style.fontSize = '11px';
      div.textContent = `job_id: ${obj.job_id}`;
      links.appendChild(div);
      lastJobId = obj.job_id;
    }
    updatePreviews(obj);
  }

  async function postForm(url, formData) {
    const res = await fetch(url, { method:'POST', body: formData });
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); } catch(e) { data = { detail: text }; }
    if (!res.ok) throw new Error(data.detail || 'Request failed');
    return data;
  }

  function stlParams(fd) {
    fd.append('name', $('name').value || 'cookie_cutter');
    fd.append('width_mm', $('width').value);
    fd.append('wall_mm', $('wall').value);
    fd.append('total_h_mm', $('height').value);
    fd.append('flange_h_mm', $('flangeH').value);
    fd.append('flange_out_mm', $('flangeOut').value);
    fd.append('cleanup_mm', $('cleanup').value);
    fd.append('tip_smooth_mm', $('tipSmooth').value);
    fd.append('keep_holes', $('keepHoles').checked);
    fd.append('min_component_area_mm2', $('area').value);
  }

  $('btnStep1').onclick = async () => {
    try {
      setStatus('Loading outline...');
      setLinks(null);
      $('pngPreview').innerHTML = '<span class="small">Loading PNG...</span>';
      $('svgPreview').innerHTML = '<span class="small">Tracing...</span>';

      if (mode === 'png') {
        const f = $('file').files[0];
        if (!f) throw new Error('Choose an outline image first.');
        const fd = new FormData();
        fd.append('file', f);
        fd.append('name', $('name').value || 'cookie_cutter');
        fd.append('threshold', $('thr').value);
        fd.append('simplify', $('simp').value);
        const data = await postForm('/trace/from-png', fd);
        setStatus('Outline loaded from PNG.');
        setLinks(data);
        if (data.svg) {
          $('svgPreview').innerHTML = `<iframe src="${data.svg}" aria-label="SVG preview"></iframe>`;
        }
      } else {
        const prompt = $('prompt').value.trim();
        if (!prompt) throw new Error('Enter a prompt.');
        const fd = new FormData();
        fd.append('prompt', prompt);
        fd.append('name', $('name').value || 'cookie_cutter');
        const data = await postForm('/outline/from-prompt', fd);
        setStatus('Outline generated from prompt.');
        setLinks(data);
        updatePreviews(data);
      }
    } catch (e) {
      setStatus('Error: ' + e.message);
      $('svgPreview').textContent = 'Failed.';
    }
  };

  $('btnTrace').onclick = async () => {
    try {
      if (!lastJobId) throw new Error('Run Step 1 first to get a job_id.');
      setStatus('Re-tracing with current threshold/simplify...');
      setLinks(null);
      $('svgPreview').innerHTML = '<span class="small">Tracing...</span>';

      const fd = new FormData();
      fd.append('job_id', lastJobId);
      fd.append('name', $('name').value || 'cookie_cutter');
      fd.append('threshold', $('thr').value);
      fd.append('simplify', $('simp').value);
      const data = await postForm('/trace/from-job', fd);
      setStatus('Trace updated.');
      setLinks(data);
      updatePreviews(data);
    } catch (e) {
      setStatus('Error: ' + e.message);
      $('svgPreview').textContent = 'Trace failed.';
    }
  };

  $('btnRun').onclick = async () => {
    try {
      setStatus('Generating STL...');
      setLinks(null);

      if (!lastJobId) throw new Error('Run Step 1 first to get a job_id.');

      const fd = new FormData();
      fd.append('job_id', lastJobId);
      stlParams(fd);
      const data = await postForm('/stl/from-job', fd);
      setStatus('Done! Download your files below.');
      setLinks(data);
      updatePreviews(data);
    } catch (e) {
      setStatus('Error: ' + e.message);
    }
  };
</script>
</body>
</html>
