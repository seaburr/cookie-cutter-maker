<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Cookie Cutter Maker</title>
  <link rel="icon" type="image/png" href="/static/favicon.png" />
  <style>
    body, button, input, textarea, select { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    body {
      margin: 0;
      background: radial-gradient(circle at 15% 15%, #070b12 0%, #05070d 32%, #04060a 100%);
      color: #e6edf3;
    }
    header { padding: 24px 28px; border-bottom: 1px solid #1f2a37; display:flex; align-items:center; justify-content:space-between;}
    main { display:flex; flex-direction:column; gap: 28px; padding: 16px; max-width: 1280px; margin: 0 auto; }
    .card { background: linear-gradient(145deg, #101a2b, #0c121a); border: 1px solid #22344b; border-radius: 16px; padding: 18px; box-shadow: 0 18px 46px rgba(0,0,0,0.42); }
    h2 { margin: 0 0 12px 0; font-size: 18px; font-weight:800; letter-spacing: 0.2px; }
    label { display:block; font-size: 12px; color:#9fb0c2; margin-top: 12px; margin-bottom:6px; letter-spacing: 0.1px; }
    input[type="text"], textarea { width:100%; background:#0b0f14; border:1px solid #243244; color:#e6edf3; border-radius:12px; padding:12px; box-sizing:border-box; }
    .short-input { width:80%; max-width:420px; }
    input[type="file"] { width:100%; color:#e6edf3; background:#0b0f14; border:1px solid #243244; border-radius:12px; padding:12px; cursor:pointer; box-sizing:border-box; }
    input[type="file"]::file-selector-button { background:#223043; color:#e6edf3; border:0; border-radius:10px; padding:10px 14px; margin-right:12px; cursor:pointer; font-weight:700; }
    input[type="file"]::file-selector-button:hover { background:#1f6feb; }
    .row { display:flex; gap:10px; }
    .row > div { flex:1; }
    .row.stack { flex-direction: column; }
    .row.stack > div { flex: none; }
    input[type="range"] { width:100%; }
    .tip { position:relative; display:inline-flex; align-items:center; justify-content:center; margin-left:6px; width:16px; height:16px; border:1px solid #2b3b4f; border-radius:50%; font-size:11px; line-height:14px; color:#9fb0c2; cursor:help; }
    .tip:hover { color:#e6edf3; border-color:#3b4f66; background:#162235; }
    .tip::after {
      content: attr(data-tip);
      position:absolute;
      left:50%;
      top:22px;
      transform: translateX(-50%);
      min-width: 180px;
      max-width: 260px;
      background:#111927;
      color:#e6edf3;
      border:1px solid #2b3b4f;
      border-radius:8px;
      padding:8px 10px;
      font-size:11px;
      line-height:1.3;
      box-shadow:0 8px 20px rgba(0,0,0,0.35);
      opacity:0;
      pointer-events:none;
      transition: opacity 120ms ease-out;
      z-index:10;
      white-space: normal;
    }
    .tip::before {
      content:"";
      position:absolute;
      left:50%;
      top:14px;
      transform: translateX(-50%);
      width:8px; height:8px;
      background:#111927;
      border-left:1px solid #2b3b4f;
      border-top:1px solid #2b3b4f;
      transform: translateX(-50%) rotate(45deg);
      opacity:0;
      transition: opacity 120ms ease-out;
      z-index:10;
    }
    .tip:hover::after, .tip:hover::before { opacity:1; }
    button { width:100%; margin-top:12px; background:#223043; border:0; color:white; padding:12px 14px; border-radius:12px; font-weight:700; cursor:pointer; transition:background 120ms ease-out, transform 120ms ease-out; letter-spacing:0.1px; }
    button.secondary { background:#223043; }
    button:hover { background:#1f6feb; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .status { font-size:12px; margin-top:6px; color:#9fb0c2; }
    .status.error { color:#fca5a5; }
    .status.success { color:#7ee787; }
    .status.info { color:#93c5fd; }
    .preview { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .pane { background:#0b0f14; border:1px solid #1f2a37; border-radius: 14px; overflow:hidden; min-height: 320px; }
    .pane header { padding:12px 14px; border-bottom:1px solid #1f2a37; font-size:12px; color:#9fb0c2; text-align:left; letter-spacing:0.2px; }
    .pane .content { padding:16px; min-height:340px; height:100%; box-sizing:border-box; }
    .pane.media .content { display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:12px; width:100%; }
    .pane.text .content { display:block; text-align:left; padding-right:12px; padding-left:12px; }
    .pane img, .pane iframe { width:100%; max-width:420px; aspect-ratio:1/1; height:auto; border:0; background:white; border-radius:12px; object-fit: contain; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
    #pngPreview, #svgPreview { width:100%; max-width:520px; aspect-ratio:1/1; background:white; border-radius:12px; box-shadow:0 12px 30px rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center; overflow:hidden; color:#0d1117; padding:6px; box-sizing:border-box; }
    #pngPreview img, #svgPreview img { width:100%; height:100%; object-fit:contain; border:0; }
    #svgPreview iframe { width:100%; height:100%; border:0; }
    #stlCanvas { width:100%; max-width:none; aspect-ratio: 16 / 10; min-height: 420px; height: clamp(420px, 70vw, 640px); border-radius:12px; background:#0d1117; box-shadow:0 12px 30px rgba(0,0,0,0.35); }
    #stlStatus { font-size:12px; color:#9fb0c2; text-align:center; margin-top:auto; min-height:16px; display:flex; align-items:center; justify-content:center; width:100%; }
    .links a { color:#7ee787; text-decoration:none; display:block; margin-top:6px; }
    .small { font-size: 12px; color:#9fb0c2; line-height:1.4; }
    .tabs { display:flex; gap:8px; margin-bottom: 10px; }
    .tab { flex:1; padding:10px; border-radius:12px; border:1px solid #1f2a37; background:#0b0f14; color:#c9d1d9; cursor:pointer; font-weight:600; }
    .tab.active { background:#162235; border-color:#2b3b4f; color:#e6edf3;}
    .step-grid { display:grid; grid-template-columns: minmax(420px, 1.15fr) 460px 240px; gap:20px; align-items:start; }
    .step3-grid { grid-template-columns: 340px 1fr; align-items:stretch; }
    .stl-controls { display:flex; flex-direction:column; gap:10px; }
    .stl-controls .row { flex-direction:column; gap:10px; }
    .stl-controls .row > div { flex: none; }
    .stl-controls input[type="range"] { height:6px; }
    .stl-controls label { margin-top: 6px; }
    .feature-bar { display:flex; gap:14px; align-items:center; }
    .feature { display:flex; align-items:center; gap:6px; font-size:12px; color:#9fb0c2; }
    .feature-dot { width:8px; height:8px; border-radius:50%; background:#374151; flex-shrink:0; }
    .feature-dot.on  { background:#22c55e; box-shadow:0 0 6px rgba(34,197,94,0.5); }
    .feature-dot.off { background:#ef4444; }

    @media (max-width: 768px) {
      header { padding: 12px 16px; flex-wrap: wrap; gap: 10px; }
      main { padding: 10px; gap: 16px; }
      .card { padding: 14px; border-radius: 12px; }
      h2 { font-size: 16px; }
      .short-input { width: 100%; max-width: none; }
      .step-grid { grid-template-columns: 1fr; }
      .step3-grid { grid-template-columns: 1fr; }
      .preview { grid-template-columns: 1fr; }
      .pane { min-height: unset; }
      .pane .content { min-height: unset; padding: 12px; }
      #stlCanvas { min-height: 260px; height: clamp(260px, 80vw, 420px); }
      #pngPreview, #svgPreview { max-width: 100%; }
    }
  </style>
</head>
<body>
<header>
  <div>
    <div style="font-weight:900; font-size:20px;">Cookie Cutter Maker</div>
    <div class="small">Upload and prompt → Trace → Generate STL</div>
  </div>
  <div class="feature-bar" id="featureBar" style="visibility:hidden">
    <div class="feature"><span class="feature-dot" id="dotBgRemoval"></span>Background Removal</div>
    <div class="feature"><span class="feature-dot" id="dotImgGen"></span>Image Generation</div>
  </div>
</header>

<main>
  <div class="card step-grid">
    <div>
      <h2>Step 1: Upload an image or use a prompt</h2>
      <div class="tabs">
        <button class="tab active" id="tabPng" type="button">Image Upload</button>
        <button class="tab" id="tabPrompt" type="button">Prompt (optional)</button>
      </div>

      <div id="panePng">
        <label>Image — outline, illustration, or photo</label>
        <input id="file" class="short-input" type="file" accept=".png,.jpg,.jpeg" />
      </div>

      <div id="panePrompt" style="display:none;">
        <label>Prompt</label>
        <textarea id="prompt" rows="4" placeholder="e.g., a pajama shirt icon silhouette, single closed contour, simple outline"></textarea>
        <div class="small" style="margin-top:6px;">
          Requires <code>OPENAI_API_KEY</code> set in the container. Otherwise this endpoint will return an error.
        </div>
      </div>

      <label>Name</label>
      <input id="name" class="short-input" type="text" value="cookie_cutter" />

      <button id="btnStep1" class="secondary" type="button">Load image (upload or prompt)</button>
      <div id="step1Status" class="status"></div>
    </div>
    <div class="pane media">
      <header>Image</header>
      <div class="content">
        <div id="pngPreview" class="small">Step 1 will show your uploaded or generated image.</div>
      </div>
    </div>
    <div class="pane text">
      <header>Supported image types</header>
      <div class="content small">
        <p style="margin:0 0 10px 0;">Accepts <b>PNG or JPG</b>. The pipeline detects the image type automatically and picks the best extraction method.</p>
        <table style="width:100%;border-collapse:collapse;font-size:11px;">
          <tr style="border-bottom:1px solid #1f2a37;">
            <td style="padding:6px 4px;color:#e6edf3;font-weight:700;">Outlines &amp; clip-art</td>
            <td style="padding:6px 4px;color:#9fb0c2;">Black on white, coloring-book style. Fastest — uses simple threshold.</td>
          </tr>
          <tr style="border-bottom:1px solid #1f2a37;">
            <td style="padding:6px 4px;color:#e6edf3;font-weight:700;">Illustrations &amp; logos</td>
            <td style="padding:6px 4px;color:#9fb0c2;">Subject on a solid or plain background. Uses colour-distance extraction.</td>
          </tr>
          <tr>
            <td style="padding:6px 4px;color:#e6edf3;font-weight:700;">Photos</td>
            <td style="padding:6px 4px;color:#9fb0c2;">Any background. Uses local U2Net AI (no API key, runs offline).</td>
          </tr>
        </table>
        <p style="margin:10px 0 0 0;color:#9fb0c2;">Keep shapes simple and avoid thin lines for best print results.</p>
      </div>
    </div>
  </div>

  <div class="card step-grid">
    <div>
      <h2>Step 2: Trace tuning (SVG)</h2>
      <div class="row stack">
        <div>
          <label>Threshold: <span id="thrVal">200</span> <span class="tip" data-tip="Black/white cutoff for tracing; lower = more pixels counted as ink.">?</span></label>
          <input id="thr" type="range" min="50" max="250" value="200" step="1"/>
        </div>
        <div>
          <label>Simplify: <span id="simpVal">0.002</span> <span class="tip" data-tip="Douglas-Peucker tolerance; higher = fewer nodes and smoother outline.">?</span></label>
          <input id="simp" type="range" min="0.0005" max="0.01" value="0.002" step="0.0005"/>
        </div>
        <div>
          <label>Smooth radius (px): <span id="smoothVal">1.0</span> <span class="tip" data-tip="Light Gaussian blur to knock out speckle noise before tracing.">?</span></label>
          <input id="smooth" type="range" min="0" max="4.0" value="1.0" step="0.1"/>
        </div>
      </div>
      <button id="btnTrace" class="secondary" type="button">Trace</button>
    </div>
    <div class="pane media">
      <header>Traced SVG</header>
      <div class="content">
        <div id="svgPreview" class="small">Run step 1, then step 2 to preview.</div>
      </div>
    </div>
    <div class="pane text">
      <header>Tips</header>
      <div class="content small">
        <ul>
          <li>If tracing is jagged, increase <b>Simplify</b>.</li>
          <li><b>Threshold</b> applies only to outline/binary images. For photos it is ignored.</li>
          <li>Re-run this step as much as you need; no new prompt tokens.</li>
        </ul>
      </div>
    </div>
  </div>

  <div class="card step-grid step3-grid">
    <div class="stl-controls">
      <h2>Step 3: STL settings</h2>

      <div class="row">
        <div>
          <label>Width (mm): <span id="widthVal">95</span> <span class="tip" data-tip="Overall cutter width across its widest point.">?</span></label>
          <input id="width" type="range" min="40" max="170" value="95" step="1"/>
        </div>
        <div>
          <label>Wall (mm): <span id="wallVal">1.0</span> <span class="tip" data-tip="Thickness of the cutting wall. Increase to strengthen thin shapes.">?</span></label>
          <input id="wall" type="range" min="0.8" max="2.0" value="1.0" step="0.1"/>
        </div>
      </div>

      <div class="row">
        <div>
      <label>Total height (mm): <span id="heightVal">25</span> <span class="tip" data-tip="Overall wall height of the cutter.">?</span></label>
      <input id="height" type="range" min="16" max="40" value="25" step="1"/>
    </div>
    <div>
      <label>Flange height (mm): <span id="flangeHVal">7.226</span> <span class="tip" data-tip="How tall the grip flange is above the cutting edge.">?</span></label>
      <input id="flangeH" type="range" min="3" max="14" value="7.226" step="0.1"/>
    </div>
  </div>

      <label>Flange outward (mm): <span id="flangeOutVal">5</span> <span class="tip" data-tip="How far the grip flange sticks out horizontally.">?</span></label>
      <input id="flangeOut" type="range" min="0" max="12" value="5" step="0.5"/>

      <div class="row">
        <div>
          <label>Cleanup (mm): <span id="cleanupVal">0.5</span> <span class="tip" data-tip="Morphological smoothing to remove tiny zig-zags or noise before offsetting.">?</span></label>
          <input id="cleanup" type="range" min="0" max="2" value="0.5" step="0.1"/>
        </div>
        <div>
          <label>Tip smoothing (mm): <span id="tipSmoothVal">0.6</span> <span class="tip" data-tip="Rounds sharp corners so inner offsets don’t collapse to paper-thin walls.">?</span></label>
          <input id="tipSmooth" type="range" min="0" max="2" value="0.6" step="0.05"/>
        </div>
        <div>
          <label>Keep holes <span class="tip" data-tip="Preserve interior holes instead of filling them before offsetting.">?</span></label>
          <input id="keepHoles" type="checkbox" />
        </div>
      </div>
      <label>Min island area (mm²): <span id="areaVal">25</span> <span class="tip" data-tip="Discard tiny disconnected islands below this area to avoid fragile crumbs.">?</span></label>
      <input id="area" type="range" min="1" max="200" value="25" step="1"/>

      <button id="btnRun" type="button">Generate STL</button>
      <div id="status" class="small" style="margin-top:10px;"></div>
      <div class="links" id="links"></div>
    </div>
    <div class="pane media">
      <header>STL Preview</header>
      <div class="content">
        <canvas id="stlCanvas"></canvas>
        <div id="stlStatus" class="small">Generate STL to preview.</div>
      </div>
    </div>
  </div>

</main>

<script>
  fetch('/features').then(r => r.json()).then(f => {
    document.getElementById('dotBgRemoval').className = 'feature-dot ' + (f.background_removal ? 'on' : 'off');
    document.getElementById('dotImgGen').className    = 'feature-dot ' + (f.image_generation   ? 'on' : 'off');
    document.getElementById('featureBar').style.visibility = 'visible';
  }).catch(() => {});
</script>
<script>
  // Lightweight STL viewer via Three.js + STLLoader.
  // Tries local copies in /static first; falls back to CDN if not present.
  let renderer, scene, camera, controls, stlMesh;
  async function ensureThree() {
    if (window.THREE && window.STLLoader && window.OrbitControls) return;
    const localLibs = [
      "/static/three.min.js",
      "/static/STLLoader.js",
      "/static/OrbitControls.js",
    ];
    const cdnLibs = [
      "https://unpkg.com/three@0.158.0/build/three.min.js",
      "https://unpkg.com/three@0.158.0/examples/js/loaders/STLLoader.js",
      "https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js",
    ];
    const tryLoad = (src) =>
      new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = src;
        s.crossOrigin = "anonymous";
        s.onload = resolve;
        s.onerror = () => reject(new Error("Failed to load " + src));
        document.head.appendChild(s);
      });
    try {
      for (const src of localLibs) await tryLoad(src);
    } catch (e) {
      // fallback to CDN
      for (const src of cdnLibs) await tryLoad(src);
    }
  }

  function initStlViewer() {
    const canvas = document.getElementById('stlCanvas');
    if (!canvas) return;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight || Math.round(canvas.clientWidth * 0.625);
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(w, h, false);
    renderer.setPixelRatio(window.devicePixelRatio || 1);

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
    camera.position.set(0, 0, 120);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light = new THREE.HemisphereLight(0xffffff, 0x222233, 1.1);
    scene.add(light);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(60, 80, 100);
    scene.add(dir);

    const grid = new THREE.GridHelper(160, 8, 0x334155, 0x1e293b);
    grid.position.y = -40;
    scene.add(grid);

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    window.addEventListener('resize', () => {
      if (!renderer || !camera) return;
      const sizeW = canvas.clientWidth;
      const sizeH = canvas.clientHeight || Math.round(sizeW * 0.625);
      renderer.setSize(sizeW, sizeH, false);
      camera.aspect = sizeW / sizeH;
      camera.updateProjectionMatrix();
    });
  }

  window.loadStl = async (url) => {
    try {
      const status = document.getElementById('stlStatus');
      if (status) status.textContent = 'Loading STL viewer...';
      await ensureThree();
      if (!renderer) initStlViewer();
      if (status) status.textContent = 'Loading STL mesh...';
      console.log('loadStl fetching', url);
      const loader = new THREE.STLLoader();
      loader.load(url, (geom) => {
        console.log('loadStl success', url);
        if (stlMesh) {
          scene.remove(stlMesh);
          stlMesh.geometry.dispose();
        }
        geom.computeBoundingBox();
        const mat = new THREE.MeshStandardMaterial({ color: 0x8ab4f8, metalness: 0.1, roughness: 0.35 });
        stlMesh = new THREE.Mesh(geom, mat);
        scene.add(stlMesh);

        const bbox = geom.boundingBox;
        const size = bbox.getSize(new THREE.Vector3());
        const center = bbox.getCenter(new THREE.Vector3());
        stlMesh.position.sub(center);
        const maxDim = Math.max(size.x, size.y, size.z);
        const camDist = maxDim * 1.6;
        camera.position.set(camDist, camDist, camDist);
        camera.lookAt(0,0,0);
        controls.target.set(0,0,0);
        controls.update();

        const status = document.getElementById('stlStatus');
        if (status) status.textContent = 'Drag to orbit • Scroll to zoom';
      }, undefined, (err) => {
        const status = document.getElementById('stlStatus');
        if (status) status.textContent = 'Failed to load STL';
        console.error(err);
      });
    } catch (e) {
      const status = document.getElementById('stlStatus');
      if (status) status.textContent = 'Viewer failed to load';
      console.error('loadStl error', e);
    }
  };

  const $ = (id) => document.getElementById(id);

  function bindRange(id, outId, fmt=(v)=>v) {
    const el = $(id);
    const out = $(outId);
    const upd = () => out.textContent = fmt(el.value);
    el.addEventListener('input', upd);
    upd();
  }

  bindRange('width','widthVal');
  bindRange('wall','wallVal', v => Number(v).toFixed(1));
  bindRange('height','heightVal');
  bindRange('flangeH','flangeHVal', v => Number(v).toFixed(3));
  bindRange('flangeOut','flangeOutVal');
  bindRange('thr','thrVal');
  bindRange('simp','simpVal', v => Number(v).toFixed(4));
  bindRange('smooth','smoothVal', v => Number(v).toFixed(1));
  bindRange('cleanup','cleanupVal', v => Number(v).toFixed(1));
  bindRange('tipSmooth','tipSmoothVal', v => Number(v).toFixed(2));
  bindRange('area','areaVal');

  // Tabs
  const tabPng = $('tabPng');
  const tabPrompt = $('tabPrompt');
  const panePng = $('panePng');
  const panePrompt = $('panePrompt');
  let mode = 'png';
  let lastJobId = null;
  let lastPngUrl = null;

  tabPng.onclick = () => {
    mode = 'png';
    tabPng.classList.add('active'); tabPrompt.classList.remove('active');
    panePng.style.display = ''; panePrompt.style.display = 'none';
  };
  tabPrompt.onclick = () => {
    mode = 'prompt';
    tabPrompt.classList.add('active'); tabPng.classList.remove('active');
    panePrompt.style.display = ''; panePng.style.display = 'none';
  };

  function setStatus(msg) { $('status').textContent = msg; }
  const MODE_LABELS = {
    binary:    { label: 'outline',    title: 'Pre-drawn outline — classic threshold path' },
    simple_bg: { label: 'photo · bg', title: 'Uniform background detected — colour-distance extraction' },
    complex:   { label: 'photo · ai', title: 'Complex background — rembg (local) or graph-cut fallback' },
  };

  function setStepStatus(msg, type='info', extractionMode='', warning='') {
    const el = $('step1Status');
    if (!el) return;
    let html = msg ? `<span>${msg}</span>` : '';
    if (extractionMode && MODE_LABELS[extractionMode]) {
      const m = MODE_LABELS[extractionMode];
      html += ` <span style="display:inline-block;margin-left:8px;padding:2px 8px;border-radius:20px;font-size:10px;font-weight:700;background:#162235;border:1px solid #2b3b4f;color:#93c5fd;" title="${m.title}">${m.label}</span>`;
    }
    if (warning) {
      html += `<div style="margin-top:6px;color:#fcd34d;font-size:11px;">⚠ ${warning}</div>`;
    }
    el.innerHTML = html || '';
    el.className = 'status ' + (msg ? type : '');
  }
  function updatePreviews(obj) {
    console.log('updatePreviews payload:', obj);
    if (obj?.png) {
      lastPngUrl = obj.png;
      $('pngPreview').innerHTML = `<img src="${obj.png}" alt="PNG preview">`;
    }
    if (obj?.svg) {
      $('svgPreview').innerHTML = `<iframe src="${obj.svg}" aria-label="SVG preview"></iframe>`;
    }
    if (obj?.stl && typeof window.loadStl === 'function') {
      window.loadStl(obj.stl);
    }
  }
  function setLinks(obj) {
    const links = $('links');
    links.innerHTML = '';
    if (!obj) return;
    for (const [k,v] of Object.entries(obj)) {
      if (k === 'job_id') continue;
      if (typeof v === 'string' && v.startsWith('/files/')) {
        const a = document.createElement('a');
        a.href = v;
        if (k.toLowerCase() === 'zip') {
          a.textContent = 'Download All (zip)';
        } else {
          a.textContent = `Download ${k.toUpperCase()}`;
        }
        a.target = '_blank';
        links.appendChild(a);
      }
    }
    if (obj.job_id) {
      const div = document.createElement('div');
      div.className = 'small';
      div.style.marginTop = '10px';
      div.style.textAlign = 'center';
      div.style.fontSize = '11px';
      div.textContent = `job_id: ${obj.job_id}`;
      links.appendChild(div);
      lastJobId = obj.job_id;
    }
    updatePreviews(obj);
  }

  async function postForm(url, formData) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), 30000);
    let res;
    try {
      res = await fetch(url, { method:'POST', body: formData, signal: controller.signal });
    } catch (e) {
      if (e.name === 'AbortError') throw new Error('Request timed out after 30 s. The server may be overloaded or unavailable.');
      throw e;
    } finally {
      clearTimeout(timer);
    }
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); } catch(e) { data = { detail: text }; }
    if (!res.ok) throw new Error(data.detail || 'Request failed');
    return data;
  }

  function stlParams(fd) {
    fd.append('name', $('name').value || 'cookie_cutter');
    fd.append('width_mm', $('width').value);
    fd.append('wall_mm', $('wall').value);
    fd.append('total_h_mm', $('height').value);
    fd.append('flange_h_mm', $('flangeH').value);
    fd.append('flange_out_mm', $('flangeOut').value);
    fd.append('cleanup_mm', $('cleanup').value);
    fd.append('tip_smooth_mm', $('tipSmooth').value);
    fd.append('keep_holes', $('keepHoles').checked);
    fd.append('min_component_area_mm2', $('area').value);
  }

  $('btnStep1').onclick = async () => {
    try {
      setStatus('Loading image...');
      setStepStatus('Loading image...', 'info');
      setLinks(null);
      $('pngPreview').innerHTML = '<span class="small">Loading image...</span>';
      $('svgPreview').innerHTML = '<span class="small">Tracing...</span>';

      if (mode === 'png') {
        const f = $('file').files[0];
        if (!f) throw new Error('Choose an image first.');
        const fd = new FormData();
        fd.append('file', f);
        fd.append('name', $('name').value || 'cookie_cutter');
        fd.append('threshold', $('thr').value);
        fd.append('simplify', $('simp').value);
        fd.append('smooth_radius', $('smooth').value);
        const data = await postForm('/trace/from-png', fd);
        setStatus('Outline loaded.');
        setStepStatus('Outline loaded.', 'success', data.extraction_mode, data.warning || '');
        setLinks(data);
        if (data.svg) {
          $('svgPreview').innerHTML = `<iframe src="${data.svg}" aria-label="SVG preview"></iframe>`;
        }
      } else {
        const prompt = $('prompt').value.trim();
        if (!prompt) throw new Error('Enter a prompt.');
        const fd = new FormData();
        fd.append('prompt', prompt);
        fd.append('name', $('name').value || 'cookie_cutter');
        const data = await postForm('/outline/from-prompt', fd);
        setStatus('Outline generated from prompt.');
        setStepStatus('Outline generated from prompt.', 'success', data.extraction_mode || '', data.warning || '');
        setLinks(data);
        updatePreviews(data);
      }
    } catch (e) {
      setStatus(e.message || 'Request failed');
      setStepStatus(e.message || 'Request failed', 'error');
      $('svgPreview').textContent = 'Failed.';
    }
  };

  $('btnTrace').onclick = async () => {
    try {
      if (!lastJobId) throw new Error('Run Step 1 first to get a job_id.');
      setStatus('Re-tracing with current threshold/simplify...');
      setLinks(null);
      $('svgPreview').innerHTML = '<span class="small">Tracing...</span>';

      const fd = new FormData();
      fd.append('job_id', lastJobId);
      fd.append('name', $('name').value || 'cookie_cutter');
      fd.append('threshold', $('thr').value);
      fd.append('simplify', $('simp').value);
      fd.append('smooth_radius', $('smooth').value);
      const data = await postForm('/trace/from-job', fd);
      setStatus('Trace updated.');
      setStepStatus('Trace updated.', 'success', data.extraction_mode, data.warning || '');
      setLinks(data);
      updatePreviews(data);
    } catch (e) {
      setStatus(e.message || 'Request failed');
      $('svgPreview').textContent = 'Trace failed.';
    }
  };

  $('btnRun').onclick = async () => {
    try {
      setStatus('Generating STL...');
      setLinks(null);

      if (!lastJobId) throw new Error('Run Step 1 first to get a job_id.');

      const fd = new FormData();
      fd.append('job_id', lastJobId);
      stlParams(fd);
      const data = await postForm('/stl/from-job', fd);
      setStatus('Done! Download your files below.');
      setLinks(data);
      updatePreviews(data);
    } catch (e) {
      setStatus(e.message || 'Request failed');
    }
  };
</script>
</body>
</html>
